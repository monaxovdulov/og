# ARCHITECTURE.md

Документ описывает архитектуру телеграм-квиз-бота и дев-агента (далее «система»), текущее устройство репозитория, потоки данных, состояния, точки расширения и нефункциональные требования. Основано на существующем коде и согласованных UX/данных.

---

## 1. Цели и границы

**Цель:** локальный квиз-бот с банком вопросов в JSON. Без генерации задач ИИ, без внешних API, без БД — всё на файловом хранилище.

**Границы:**

* Канал взаимодействия — личный чат Telegram.
* Жизненный цикл: /start → главное меню → режим игры → серия вопросов → итоги.
* Данные: `database/topics.json`, `database/questions.json`, `database/users.json`.
* Контент — только из локальных файлов (никаких «придуманных» вопросов).
* Регистрация не нужна: профиль создаётся лениво при первом касании.

---

## 2. Карта репозитория (компоненты)

```
app/
  __main__.py         — точка входа (polling)
  core.py             — конфиг/логгер/TeleBot/CallbackShield/Repo
  commands.py         — /start, главное меню
  callbacks.py        — парсинг callback_data, роутинг по неймспейсам
  handlers.py         — бизнес-обработчики (меню/игра/настройки/вопросы)
  keyboards.py        — типы, константы, билд коллбеков, все inline-клавиатуры
  guard.py            — CallbackShield (анти-дупликат/сериализация)
  repo.py             — файловый репозиторий (topics, questions, users)
database/
  topics.json         — темы (id/title/emoji)
  questions.json      — задания (см. схему)
  users.json          — пользователи (пусто на старте, создаётся лениво)
```

Сопутствующие: `pyproject.toml`, `uv.lock`, egg-info — для сборки и воспроизводимости.

---

## 3. Высокоуровневая архитектура

```
┌─────────────────────┐          ┌───────────────────────┐
│  Telegram (личка)   │  updates │  app.__main__ (poll)  │
└─────────┬───────────┘──────────▶  TeleBot.infinity...  │
          │                          │
          │                          ▼
          │                 ┌─────────────────┐
          │                 │  commands.py    │  /start
          │                 └───────┬─────────┘
          │                         ▼
          │                 ┌─────────────────┐
          │  callback_data  │  callbacks.py   │  парсинг/роутинг
          │ ───────────────▶└───────┬─────────┘
          │                         │
          │                         ▼
          │                 ┌─────────────────┐
          │                 │  handlers.py    │  бизнес-логика
          │                 └──┬──────────────┘
          │                    │
          │         read/write │
          │                    ▼
          │                 ┌─────────────────┐
          │                 │   repo.py       │  файлы
          │                 └──┬─────┬────────┘
          │                    │     │
          │                    │     │  load-once (RO)
          │                    │     ▼
          │                 topics  questions
          │
          ▼
    User messages
```

Ключевые роли:

* **UI-слой** (commands/callbacks/handlers/keyboards) — показывает тексты/кнопки и принимает события.
* **Guard** — защита от дублей и гонок коллбеков.
* **Repo** — загрузка банка, индексация и файловая персистентность пользователей.

---

## 4. Потоки данных (Data Flow)

1. **Инициализация процесса (`app/core.py`)**

   * Настройка логгера.
   * Чтение `BOT_TOKEN`.
   * Создание `TeleBot` (HTML parse mode).
   * Инициализация `CallbackShield`.
   * Инициализация `Repo`, загрузка:

     * `topics.json` → список + индекс по `id`.
     * `questions.json` → массив + индексы: `by_id`, `by_topic`, `by_topic_diff`.
     * `users.json` → документ (`users` — словарь по `user_id`).

2. **Первое касание (`/start`)**

   * `repo.ensure_user(user_id, username)` — ленивое создание профиля (`prefs`, `session=null`, счётчики).
   * Отправка главного меню (клавиатура).

3. **Выбор темы/режима**

   * Экран «Темы» строится **из `repo.get_topics()`** (никаких захардкоженных списков).
   * «По теме» → `repo.start_session(user_id, mode="series", topic_id, diff, qcount)`:

     * Подбор N вопросов по теме/сложности (случайным сэмплом).
     * Если `len(pool) < qcount` → пустой результат → мягкий алерт на UI.
     * Иначе создаётся `session` с `question_ids`, `index=0`.

4. **Вопрос → ответ**

   * Рендер вопроса по `repo.get_current_question(user_id)`.
   * При ответе:

     * Normalization (по типу).
     * Сверка с `correct_answer` из банка.
     * Запись в `users.session.answers[qid]` + обновление `stats`.
     * При `sol=imm` — показать объяснение; при `sol=end` — сохранить `qid` в `solutions_qids`.
     * Активировать «Дальше →».

5. **Переход дальше / финиш**

   * `repo.advance(user_id)` — `index += 1`, возвращает `has_more`.
   * Если серия закончилась: показать «Итоги», затем `repo.finish(user_id)` → `session=null`.

Все изменения `users` сопровождаются **атомарной записью** в `users.json`.

---

## 5. Состояния приложения (FSM)

**Глобальные для пользователя:**

* `idle` — нет активной сессии (`session=null`);
* `asking` — показан текущий вопрос, ответ ещё не принят;
* `await_text_input` — ожидаем сообщение с числом/текстом;
* `answered` — зафиксирован ответ, доступно «Дальше →».

**Переходы:**

* `idle → asking` — старт серии/темы/дневного.
* `asking → await_text_input` — команда «Ввести ответ» для `numeric`/`text`.
* `await_text_input → asked/answered` — пришло валидное/невалидное сообщение.
* `asking → answered` — клик по `single_choice`/коммит `multi_choice`.
* `answered → asking` — «Дальше →».
* `answered → idle` — завершение серии (последний вопрос).
* Любой → `idle` — «Домой» (по политике либо спросить подтверждение, либо мягко оставить `session`).

**Идемпотентность:** обработчики должны корректно переживать повторные коллбеки (см. CallbackShield).

---

## 6. UI/UX договорённости (критично для архитектуры)

* **Формат коллбеков:** `"<ns>:<action>[:<arg>...]"`, где `ns ∈ {m,p,t,s,q,nav}`.
* **Ограничения Telegram:**

  * 64 байта на `callback_data` — в коллбеках передаём только короткие маркеры (индексы, id), а не свободный текст.
  * 4096 символов на сообщение — тексты вопроса и решения должны укладываться.
* **Клавиатуры** рендерятся централизованно (`keyboards.py`) — каждый «экран» генерирует свою раскладку.
* **Тексты сообщений** редактируются по возможности (`edit_message_text`); если нельзя — отправляется новое.

---

## 7. Guard/Concurrency

**CallbackShield (`app/guard.py`):**

* **Deduplication:** блокирует повтор одного и того же `(user, chat, message, data)` в окне `dedup_ttl` (≈0.8с). Это устраняет «двойные тапы».
* **In-flight serialization:** на пользователя ставится «занято» на окно `in_flight_timeout` (≈2с). Повторные события — вежливый ответ «Подождите секунду…».
* Всегда `release` в `finally`, чтобы не залипало состояние.

**Последствия для архитектуры:**

* Бизнес-обработчики можно писать как чистые пошаговые функции: гонок почти нет.
* Запись `users.json` краткая и атомарная — риск повреждения минимален.

---

## 8. Репозиторий данных (`app/repo.py`)

**Задачи:**

* Разовый **RO-запуск**: загрузка и индексация `topics.json`/`questions.json` (in-memory).
* Ленивая инициализация пользователя в `users.json`.
* Подбор серии (по теме/сложности/количеству).
* Управление сессией: `start_session`/`get_current_question`/`record_answer`/`advance`/`finish`.
* Ввод `numeric/text`: `set_await_input`/`clear_await_input`.

**Индексы:**

* `q_by_id: {id → question}`
* `q_by_topic: {topic_id → [question]}`
* `q_by_topic_diff: {(topic_id, diff) → [question]}`

**Персистентность `users`:**

* Хранится в виде документа: `{"version":"users.v1","updated_at":ISO,"users":{ "<user_id>": {…} }}`.
* Атомарная запись: `*.tmp → os.replace`.
* Рекомендовано хранить `.bak` (бэкап до перезаписи).

**Валидация при загрузке банка:**

* Уникальность `question.id`.
* Ссылочная целостность `topic_ids` ∈ `topics`.
* (Расширяемо под VALIDATION_RULES.md.)

---

## 9. Модель данных (сводно)

### Темы (`topics.json`)

* `id: str` — короткий стабильный идентификатор.
* `title: str` — заголовок для UI.
* `emoji: str` — украшение для сетки тем.
* (опционально) `version: "YYYY-MM"` — метка версии набора тем.

### Вопросы (`questions.json`)

* Обязательные поля:
  `id`, `title`, `topic_ids[]`, `difficulty ∈ {e,m,h}`,
  `answer_format ∈ {single_choice,multi_choice,numeric,text}`,
  `statement`, `question`, `correct_answer`.
* Опциональные:
  `options[]` — для choice-типов;
  `solution_explanation` — текст решения.

### Пользователи (`users.json`, per user)

* `prefs`: `{ qcount: 3|5|10, diff: "e"|"m"|"h", sol: "imm"|"end" }`.
* `session`: `{ mode, topic_id, question_ids[], index, answers{qid→{format,value,is_correct}}, await_input{qid,format}|null, solutions_qids[] } | null`.
* `last_topic_id`: для кнопок на итогах.
* `stats`: `total{answered,correct}`, `by_topic{topic_id→{answered,correct}}`.
* (метаданные) `created_at`, `updated_at`.

---

## 10. Сценарии (последовательности)

### 10.1. `/start`

1. `ensure_user` (если новый — создаёт запись).
2. Отправка главного меню.

### 10.2. «Темы» → выбор темы

1. Рендер сетки тем (2×N, с пагинацией).
2. `p:topic:<id>` → `start_session`:

   * `pick_series(topic_id, diff, qcount)`:

     * если мало — алерт, остаёмся на «Темы»;
     * иначе — `session` + первый вопрос.

### 10.3. Ответ `single_choice`

1. Клик по варианту → фиксация индекса.
2. Сверка с `correct_answer`.
3. Фидбек + «Дальше →».

### 10.4. Ответ `multi_choice`

1. Пользователь отмечает чекбоксы (локально в UI).
2. `commit` → сравнение множеств; фидбек + «Дальше →».

### 10.5. Ответ `numeric/text`

1. «Ввести ответ» → `await_input = {qid, format}`.
2. Приходит сообщение → нормализация → сверка → фидбек.
3. `await_input → null`, «Дальше →».

### 10.6. Решение (imm/end)

* `imm` — показать сейчас.
* `end` — копим `qid` и показываем блоком на экране итогов.

### 10.7. Завершение серии

1. Подсчёт «правильных из N».
2. Опционально — выдача решений (если `end`).
3. Кнопки: «Ещё по теме», «Играть ещё», «Другая тема», «Меню».
4. `session=null`.

---

## 11. Ошибки и восстановление

* **Недостаточно вопросов:** UI-алерт + предложения: «другая тема», «снизить сложность», «уменьшить qcount».
* **Повторные клики:** CallbackShield отвечает «Уже обрабатываю…», состояние не меняется.
* **Невалидный ввод (numeric/text):** мягкая подсказка; остаёмся в режиме ввода; кнопка «Отмена ввода».
* **Битый `users.json`:** при чтении — создаётся новый пустой документ (логировать!), предыдущий файл сохранять как `.bak`.
* **Несовпадение индексов/границ:** безопасно вернуть в `asking` с подсказкой «Обновил состояние, можно продолжать».

---

## 12. Конфигурация и окружение

* `BOT_TOKEN` — обязателен (иначе `RuntimeError`).
* Пути (опционально через env):
  `TOPICS_PATH` (default `database/topics.json`)
  `QUESTIONS_PATH` (default `database/questions.json`)
  `USERS_PATH` (default `database/users.json`)
* Логгирование: уровень берётся из `LOGLEVEL` (default INFO).

---

## 13. Нефункциональные требования

* **Производительность:** обработка коллбеков ≤ 500 мс (без I/O сети).
* **Надёжность:** атомарная запись файлов + бэкап.
* **Безопасность/Privacy:** храним минимум данных (id/username), всё локально.
* **Совместимость:** Python 3.12+, `pyTelegramBotAPI`/`telebot`.

---

## 14. Наблюдаемость (Observability)

Рекомендуемые события логгировать:

* start: загрузка банка (количество тем/вопросов), чтение пользователей.
* user: создан профиль, смена prefs, старт/финиш серии.
* question: показ qid, принят ответ (is_correct), показ решения (imm/end).
* error: валидация банка, битый JSON, исключения обработчиков, недостаток вопросов.

Структура лога: `ts level module: message (user_id=?, qid=?, topic=?, action=?, verdict=?)`.

---

## 15. Риски и смягчение

* **Повреждение `users.json` при падении процесса:** атомарная запись + `.bak`.
* **Длинные тексты/варианты ломают UI:** правила валидации + предупреждения при симуляции.
* **Двойные клики «съедают» состояние:** CallbackShield + идемпотентные обработчики.
* **Несогласованность банка (topic_ids):** валидация при старте и при CI (будущая задача).

---

## 16. Критерии готовности архитектуры (Acceptance)

* Компоненты загружаются и инициализируются в правильном порядке; банк в памяти.
* `/start` создаёт пользователя при необходимости и показывает меню.
* «Темы» берутся из `topics.json`; выбор темы → попытка стартовать серию.
* Серия работает для всех типов заданий; решения по `imm/end` ведут себя согласно prefs.
* Все пользовательские изменения (`prefs`, `answers`, `index`) попадают в `users.json` атомарно.
* Дедуп коллбеков и сериализация на пользователя предотвращают гонки/дубли.
* Логи отражают основные события и ошибки.

---

## 17. Соглашения и стиль

* **Callback schema:** строго `ns:action[:arg...]`, без двоеточий в частях.
* **Строки UI:** короткие, нейтральные, без флуда.
* **Состояния:** минимальные и явные; ничего лишнего в `session`.
* **Данные:** источник истины — JSON; никаких дублей контента в `users.json`.

---

Этот документ фиксирует текущее устройство системы и задаёт базис для последующих доков: `VALIDATION_RULES.md`, `FSM_SPEC.md`, `CALLBACKS_CONTRACT.md`, `DATA_SCHEMAS/*`, `TEST_PLAN.md`.
